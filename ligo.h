/* -*- c-basic-offset: 2 -*- */
/*
 * Copyright (c) 2015 Renaud AUBIN
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#ifndef LIGO_H
#define LIGO_H

#include <stdlib.h>
#include <libusb.h>


#define LIGO_VERSION "1.0.0"


/* Vendors and products's ids taken from adb source */

// Google's USB Vendor ID
#define VENDOR_ID_GOOGLE        0x18d1
// Intel's USB Vendor ID
#define VENDOR_ID_INTEL         0x8087
// HTC's USB Vendor ID
#define VENDOR_ID_HTC           0x0bb4
// Samsung's USB Vendor ID
#define VENDOR_ID_SAMSUNG       0x04e8
// Motorola's USB Vendor ID
#define VENDOR_ID_MOTOROLA      0x22b8
// LG's USB Vendor ID
#define VENDOR_ID_LGE           0x1004
// Huawei's USB Vendor ID
#define VENDOR_ID_HUAWEI        0x12D1
// Acer's USB Vendor ID
#define VENDOR_ID_ACER          0x0502
// Sony Ericsson's USB Vendor ID
#define VENDOR_ID_SONY_ERICSSON 0x0FCE
// Foxconn's USB Vendor ID
#define VENDOR_ID_FOXCONN       0x0489
// Dell's USB Vendor ID
#define VENDOR_ID_DELL          0x413c
// Nvidia's USB Vendor ID
#define VENDOR_ID_NVIDIA        0x0955
// Garmin-Asus's USB Vendor ID
#define VENDOR_ID_GARMIN_ASUS   0x091E
// Sharp's USB Vendor ID
#define VENDOR_ID_SHARP         0x04dd
// ZTE's USB Vendor ID
#define VENDOR_ID_ZTE           0x19D2
// Kyocera's USB Vendor ID
#define VENDOR_ID_KYOCERA       0x0482
// Pantech's USB Vendor ID
#define VENDOR_ID_PANTECH       0x10A9
// Qualcomm's USB Vendor ID
#define VENDOR_ID_QUALCOMM      0x05c6
// On-The-Go-Video's USB Vendor ID
#define VENDOR_ID_OTGV          0x2257
// NEC's USB Vendor ID
#define VENDOR_ID_NEC           0x0409
// Panasonic Mobile Communication's USB Vendor ID
#define VENDOR_ID_PMC           0x04DA
// Toshiba's USB Vendor ID
#define VENDOR_ID_TOSHIBA       0x0930
// SK Telesys's USB Vendor ID
#define VENDOR_ID_SK_TELESYS    0x1F53
// KT Tech's USB Vendor ID
#define VENDOR_ID_KT_TECH       0x2116
// Asus's USB Vendor ID
#define VENDOR_ID_ASUS          0x0b05
// Philips's USB Vendor ID
#define VENDOR_ID_PHILIPS       0x0471
// Texas Instruments's USB Vendor ID
#define VENDOR_ID_TI            0x0451
// Funai's USB Vendor ID
#define VENDOR_ID_FUNAI         0x0F1C
// Gigabyte's USB Vendor ID
#define VENDOR_ID_GIGABYTE      0x0414
// IRiver's USB Vendor ID
#define VENDOR_ID_IRIVER        0x2420
// Compal's USB Vendor ID
#define VENDOR_ID_COMPAL        0x1219
// T & A Mobile Phones' USB Vendor ID
#define VENDOR_ID_T_AND_A       0x1BBB
// LenovoMobile's USB Vendor ID
#define VENDOR_ID_LENOVOMOBILE  0x2006
// Lenovo's USB Vendor ID
#define VENDOR_ID_LENOVO        0x17EF
// Vizio's USB Vendor ID
#define VENDOR_ID_VIZIO         0xE040
// K-Touch's USB Vendor ID
#define VENDOR_ID_K_TOUCH       0x24E3
// Pegatron's USB Vendor ID
#define VENDOR_ID_PEGATRON      0x1D4D
// Archos's USB Vendor ID
#define VENDOR_ID_ARCHOS        0x0E79
// Positivo's USB Vendor ID
#define VENDOR_ID_POSITIVO      0x1662
// Fujitsu's USB Vendor ID
#define VENDOR_ID_FUJITSU       0x04C5
// Lumigon's USB Vendor ID
#define VENDOR_ID_LUMIGON       0x25E3
// Quanta's USB Vendor ID
#define VENDOR_ID_QUANTA        0x0408
// INQ Mobile's USB Vendor ID
#define VENDOR_ID_INQ_MOBILE    0x2314
// Sony's USB Vendor ID
#define VENDOR_ID_SONY          0x054C
// Lab126's USB Vendor ID
#define VENDOR_ID_LAB126        0x1949
// Yulong Coolpad's USB Vendor ID
#define VENDOR_ID_YULONG_COOLPAD 0x1EBF
// Kobo's USB Vendor ID
#define VENDOR_ID_KOBO          0x2237
// Teleepoch's USB Vendor ID
#define VENDOR_ID_TELEEPOCH     0x2340
// AnyDATA's USB Vendor ID
#define VENDOR_ID_ANYDATA       0x16D5
// Harris's USB Vendor ID
#define VENDOR_ID_HARRIS        0x19A5
// OPPO's USB Vendor ID
#define VENDOR_ID_OPPO          0x22D9
// Xiaomi's USB Vendor ID
#define VENDOR_ID_XIAOMI        0x2717
// BYD's USB Vendor ID
#define VENDOR_ID_BYD           0x19D1
// OUYA's USB Vendor ID
#define VENDOR_ID_OUYA          0x2836
// Haier's USB Vendor ID
#define VENDOR_ID_HAIER         0x201E
// Hisense's USB Vendor ID
#define VENDOR_ID_HISENSE       0x109b
// MTK's USB Vendor ID
#define VENDOR_ID_MTK           0x0e8d
// B&N Nook's USB Vendor ID
#define VENDOR_ID_NOOK          0x2080
// Qisda's USB Vendor ID
#define VENDOR_ID_QISDA         0x1D45
// ECS's USB Vendor ID
#define VENDOR_ID_ECS           0x03fc


#define BUFFER_SIZE 16384


typedef struct ligo_accessory ligo_accessory;
struct ligo_accessory {
  unsigned char* manufacturer;
  unsigned char* model;
  unsigned char* description;
  unsigned char* version;
  unsigned char* uri;
  unsigned char* serial;
};

/* Die with fatal error. */
#define FATAL(msg)                                      \
  do {                                                  \
    fprintf(stderr,                                     \
            "Fatal error in %s on line %d: %s\n",       \
            __FILE__,                                   \
            __LINE__,                                   \
            msg);                                       \
    fflush(stderr);                                     \
    abort();                                            \
  } while (0)

/* Have our own assert, so we are sure it does not get optimized away in
 * a release build.
 */
#define ASSERT(expr)                                            \
  do {                                                          \
    if (!(expr)) {                                              \
      fprintf(stderr,                                           \
              "Assertion failed in %s on line %d: %s\n",        \
              __FILE__,                                         \
              __LINE__,                                         \
              #expr);                                           \
      abort();                                                  \
    }                                                           \
  } while (0)

struct libusb_device_handle * ligo_get_io_handle();

int ligo_open_and_claim(libusb_device *dev, int interface_number);

void ligo_init_endpoints(libusb_device *dev);

int ligo_set_configuration(libusb_device *dev);

int ligo_start_accessory_mode(libusb_device *dev, const ligo_accessory *acc);

int ligo_get_protocol_version(libusb_device *dev);

ssize_t ligo_get_device_list(libusb_context *ctx, libusb_device ***list);

int ligo_read(unsigned char* buffer,
              unsigned int timeout);

int ligo_write(unsigned char* buffer,
               unsigned int length,
               unsigned int timeout);

int ligo_init();

void ligo_exit();

#endif
